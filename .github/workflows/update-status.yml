# .github/workflows/update-eth-status.yml
# This is the full code to save in your repository.

name: Update GitHub Status with ETH Trend

on:
  schedule:
    # This schedule runs the workflow every day at midnight UTC.
    # The cron syntax is 'minute hour day month day-of-week'.
    - cron: "0 0 * * *"
  # This allows you to run the workflow manually from the Actions tab on GitHub.
  workflow_dispatch:

jobs:
  update-status:
    # This job runs on a standard GitHub-hosted Ubuntu runner.
    runs-on: ubuntu-latest
    steps:
      # Step 1: Fetch the last 24 hours of price data from the CoinGecko API.
      - name: Fetch ETH price data (last 24h)
        id: prices
        run: |
          # Use curl to silently (-s) fetch market chart data for Ethereum in USD over the last day.
          JSON_DATA=$(curl -s 'https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=1')

          # Use jq to parse the JSON and extract the first price (approx. 24h ago) and the last price (current).
          # The '.prices[0][1]' path gets the price from the first array element.
          # The '.prices[-1][1]' path gets the price from the last array element.
          PRICE_OLD=$(echo $JSON_DATA | jq -r '.prices[0][1]')
          PRICE_NEW=$(echo $JSON_DATA | jq -r '.prices[-1][1]')

          # This is the modern and recommended way to create output variables for subsequent steps.
          # We append key=value pairs to the file specified by the $GITHUB_OUTPUT environment variable.
          echo "old=$PRICE_OLD" >> $GITHUB_OUTPUT
          echo "new=$PRICE_NEW" >> $GITHUB_OUTPUT

          echo "Fetched prices -> 24h Ago: $PRICE_OLD, Current: $PRICE_NEW"

      # Step 2: Compare the old and new prices to determine the trend and construct the status message.
      - name: Compare prices and set status
        id: status
        run: |
          # The values from the previous step are available via the 'steps' context.
          PRICE_OLD=${{ steps.prices.outputs.old }}
          PRICE_NEW=${{ steps.prices.outputs.new }}

          # Use awk for safe floating-point (decimal) arithmetic, which is more reliable than shell arithmetic.
          # It prints "1" if the new price is greater than the old, otherwise "0".
          IS_UP=$(awk -v new="$PRICE_NEW" -v old="$PRICE_OLD" 'BEGIN { print (new > old) ? "1" : "0" }')

          # Calculate the percentage change, formatted to two decimal places.
          PERCENT_CHANGE=$(awk -v new="$PRICE_NEW" -v old="$PRICE_OLD" 'BEGIN { if (old > 0) { printf "%.2f", ((new - old) / old) * 100 } else { print "0.00" } }')

          # Set the status emoji and message text based on whether the price went up or down.
          if [ "$IS_UP" -eq 1 ]; then
            EMOJI=":chart_with_upwards_trend:"
            # Add a plus sign for positive changes.
            MESSAGE="ETH: \$$(printf "%.2f" $PRICE_NEW) (+${PERCENT_CHANGE}%)"
          else
            EMOJI=":chart_with_downwards_trend:"
            # The negative sign is already included from the calculation.
            MESSAGE="ETH: \$$(printf "%.2f" $PRICE_NEW) (${PERCENT_CHANGE}%)"
          fi

          # Set the final emoji and message as outputs for the next step.
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT
          echo "message=$MESSAGE" >> $GITHUB_OUTPUT

          echo "Status to be set -> $EMOJI $MESSAGE"

      # Step 3: Send the update to the GitHub GraphQL API to change your user status.
      - name: Update GitHub profile status
        env:
          # The token is securely accessed from the repository's secrets.
          # The secret can be named anything, but USER_STATUS_TOKEN is descriptive.
          GH_TOKEN: ${{ secrets.USER_BIO_TOKEN }}
        run: |
          # Construct the GraphQL mutation payload using jq. This is safer than string concatenation.
          # The query changes the user status, and the variables provide the new emoji and message.
          GRAPHQL_PAYLOAD=$(jq -n \
            --arg emoji "${{ steps.status.outputs.emoji }}" \
            --arg message "${{ steps.status.outputs.message }}" \
            '{
              "query": "mutation($status: ChangeUserStatusInput!) { changeUserStatus(input: $status) { clientMutationId } }",
              "variables": {
                "status": {
                  "emoji": $emoji,
                  "message": $message,
                  "limitedAvailability": false
                }
              }
            }')

          # Send the mutation to the GitHub GraphQL API endpoint.
          # --fail causes curl to exit with an error if the server returns an HTTP error code (e.g., 401, 403).
          curl \
            --fail -X POST \
            -H "Authorization: bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            https://api.github.com/graphql \
            -d "$GRAPHQL_PAYLOAD"
