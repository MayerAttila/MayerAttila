# .github/workflows/update-eth-status.yml
# This is the full code to save in your repository.
# This version uses awk for reliable price formatting to prevent errors.

name: Update GitHub Status with ETH Trend

on:
  schedule:
    # This schedule runs the workflow every day at midnight UTC.
    # The cron syntax is 'minute hour day month day-of-week'.
    - cron: "0 0 * * *"
  # This allows you to run the workflow manually from the Actions tab on GitHub.
  workflow_dispatch:

jobs:
  update-status:
    # This job runs on a standard GitHub-hosted Ubuntu runner.
    runs-on: ubuntu-latest
    steps:
      # Step 1: Fetch the last 24 hours of price data from the CoinGecko API.
      - name: Fetch ETH price data (last 24h)
        id: prices
        run: |
          # Use curl to silently (-s) fetch market chart data for Ethereum in USD over the last day.
          JSON_DATA=$(curl -s 'https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=1')

          # Use jq to parse the JSON and extract the first price (approx. 24h ago) and the last price (current).
          PRICE_OLD=$(echo $JSON_DATA | jq -r '.prices[0][1]')
          PRICE_NEW=$(echo $JSON_DATA | jq -r '.prices[-1][1]')

          # This is the modern and recommended way to create output variables for subsequent steps.
          # We append key=value pairs to the file specified by the $GITHUB_OUTPUT environment variable.
          echo "old=$PRICE_OLD" >> $GITHUB_OUTPUT
          echo "new=$PRICE_NEW" >> $GITHUB_OUTPUT

          echo "Fetched prices -> 24h Ago: $PRICE_OLD, Current: $PRICE_NEW"

      # Step 2: Compare prices and set status using awk for all calculations.
      - name: Compare prices and set status
        id: status
        run: |
          PRICE_OLD=${{ steps.prices.outputs.old }}
          PRICE_NEW=${{ steps.prices.outputs.new }}

          # Use a single, robust awk command for all calculations and formatting.
          # This avoids shell floating point issues entirely.
          awk -v new="$PRICE_NEW" -v old="$PRICE_OLD" '
          BEGIN {
              # Determine the trend
              is_up = (new > old);
              
              # Calculate percentage change
              if (old > 0) {
                  percent_change = ((new - old) / old) * 100;
              } else {
                  percent_change = 0;
              }

              # Format the new price to two decimal places
              formatted_price = sprintf("%.2f", new);
              
              # Set emoji and construct the message based on the trend
              if (is_up) {
                  emoji = ":chart_with_upwards_trend:";
                  message = sprintf("ETH: $%s (+%.2f%%)", formatted_price, percent_change);
              } else {
                  emoji = ":chart_with_downwards_trend:";
                  message = sprintf("ETH: $%s (%.2f%%)", formatted_price, percent_change);
              }

              # Print the key=value pairs for the GITHUB_OUTPUT file
              print "emoji=" emoji;
              print "message=" message;
          }
          ' >> $GITHUB_OUTPUT # Append the output of awk directly to the file

          # Log the planned status for easier debugging
          echo "Status to be set -> $(grep 'emoji' $GITHUB_OUTPUT | cut -d'=' -f2) $(grep 'message' $GITHUB_OUTPUT | cut -d'=' -f2)"

      # Step 3: Send the update to the GitHub GraphQL API to change your user status.
      - name: Update GitHub profile status
        env:
          # The token is securely accessed from the repository's secrets.
          # The secret must be named USER_STATUS_TOKEN in your repository settings.
          GH_TOKEN: ${{ secrets.USER_STATUS_TOKEN }}
        run: |
          # Construct the GraphQL mutation payload using jq. This is safer than string concatenation.
          GRAPHQL_PAYLOAD=$(jq -n \
            --arg emoji "${{ steps.status.outputs.emoji }}" \
            --arg message "${{ steps.status.outputs.message }}" \
            '{
              "query": "mutation($status: ChangeUserStatusInput!) { changeUserStatus(input: $status) { clientMutationId } }",
              "variables": {
                "status": {
                  "emoji": $emoji,
                  "message": $message,
                  "limitedAvailability": false
                }
              }
            }')

          # Send the mutation to the GitHub GraphQL API endpoint.
          # --fail causes curl to exit with an error if the server returns an HTTP error code (e.g., 401, 403).
          curl \
            --fail -X POST \
            -H "Authorization: bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            https://api.github.com/graphql \
            -d "$GRAPHQL_PAYLOAD"
